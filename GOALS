
# 2nd-draft goals #


IDE for knowledge

Solve problems by first encoding and uploading the knowledge into the system.
Then work with it.

Share information just like sharing code.

System knows how to "present" data as a running application.

System handles program linking.

System understands versioning and branching.

Things that are unnecessary/replaced:
 - Git
 - Jenkins
 - A build step
 

---

Buildout strategy:
 1. First build the reference implementation (might be slow)
 2. Then build the optimized version
 3. Test inputs against both versions

---

Parsing is very context-dependent

Allow users to create their own microverses, customized for their problem
space.

---

Data sharing format

 - Prefer objects with one or many keys
 - Components should only care about keys they understand
 - This allows us to add more functionality by attaching more keys
 - Field names are important and are context-free. Discourage ad-hoc object
   formats that only make sense in their context. Encourage common field
   names so that objects can be understood out of context.

# 1st-draft goals #


Giant monorepo storage of programs

Functions / files / expressions / programs

Graph database

Supports **dimensions**
 - Branching is a dimension
 - User workspaces is a dimension

Supports **presentations**
 - The presentation is the way the data is viewed
